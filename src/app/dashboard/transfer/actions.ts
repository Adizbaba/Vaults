
"use server";

import { z } from "zod";

// --- ACH Transfer ---
const externalTransferSchema = z.object({
  fromAccount: z.string(),
  bankName: z.string(),
  routingNumber: z.string(),
  accountNumber: z.string(),
  accountType: z.enum(["checking", "savings"]),
  amount: z.number(),
  memo: z.string().optional(),
});

type ExternalTransferFormValues = z.infer<typeof externalTransferSchema>;

interface ActionResult {
  success: boolean;
  message?: string;
  error?: string;
}

export async function handleAchTransfer(
  data: ExternalTransferFormValues
): Promise<ActionResult> {
  console.log("Server Action: handleAchTransfer called with data:", data);

  // Simulate backend processing & validation
  await new Promise(resolve => setTimeout(resolve, 1500)); // Simulate network delay

  if (data.amount > 10000) {
    return { success: false, error: "Transfer amount exceeds $10,000 limit for ACH." };
  }
  if (data.routingNumber === "000000000") {
     return { success: false, error: "Invalid routing number." };
  }

  // In a real app:
  // 1. Securely validate user's authority for 'fromAccount'.
  // 2. Check 'fromAccount' balance.
  // 3. Interact with an ACH processing service (e.g., Stripe, Plaid, or direct bank integration).
  // 4. Store transaction record in database with 'pending' status.
  // 5. Update account balances (e.g., hold funds).
  // 6. Send notifications.
  
  console.log(`Simulating ACH transfer: $${data.amount} from ${data.fromAccount} to ${data.bankName} (Account: ****${data.accountNumber.slice(-4)})`);
  
  // For Zelle, a transaction ID would be generated by the Zelle network or your processor.
  const transactionId = `ACH_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;
  console.log("Generated Mock ACH Transaction ID:", transactionId);


  return { success: true, message: `ACH Transfer of $${data.amount.toFixed(2)} initiated. Transaction ID: ${transactionId}` };
}


// --- Zelle Transfer ---

interface ZelleRecipient {
  identifier: string; // email or phone
  name: string;
  isRegistered: boolean;
}

interface ZelleSearchSuccessResult {
  success: true;
  recipient: ZelleRecipient;
}
interface ZelleSearchErrorResult {
  success: false;
  error: string;
  recipient?: null;
}
type ZelleSearchResult = ZelleSearchSuccessResult | ZelleSearchErrorResult;


export async function searchZelleRecipient(identifier: string): Promise<ZelleSearchResult> {
  console.log("Server Action: searchZelleRecipient called with identifier:", identifier);
  await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate network delay

  // Mocked recipient data
  const mockRecipients: Record<string, ZelleRecipient> = {
    "user@example.com": { identifier: "user@example.com", name: "Jane Doe (Example)", isRegistered: true },
    "1234567890": { identifier: "1234567890", name: "John Smith (Example)", isRegistered: true },
    "unregistered@example.com": { identifier: "unregistered@example.com", name: "Alex Ray (Unregistered)", isRegistered: false },
  };

  const found = mockRecipients[identifier.toLowerCase()];

  if (found) {
    return { success: true, recipient: found };
  } else if (identifier.includes("testfound")) { // For testing UI a found but unregistered user
     return { success: true, recipient: { identifier: identifier, name: "Test User Found", isRegistered: Math.random() > 0.3 } };
  }
  
  return { success: false, error: "Recipient not found or not enrolled with Zelle® using this contact information." };
}


const zelleSendSchemaServer = z.object({
  fromAccount: z.string(),
  recipientIdentifier: z.string(),
  recipientName: z.string(),
  amount: z.number(),
  memo: z.string().optional(),
});
type ZelleSendFormValuesServer = z.infer<typeof zelleSendSchemaServer>;

export async function handleZelleSendMoney(data: ZelleSendFormValuesServer): Promise<ActionResult> {
  console.log("Server Action: handleZelleSendMoney called with data:", data);
  await new Promise(resolve => setTimeout(resolve, 1500));

  if (data.amount > 500) { // Example limit
    return { success: false, error: "Zelle® send limit is $500 per transaction for this account." };
  }

  // In a real app:
  // 1. Validate 'fromAccount' balance and user authority.
  // 2. Interact with Zelle SDK/API to initiate payment.
  // 3. Record transaction in database.
  // 4. Update account balance.
  // 5. Send notifications.
  const transactionId = `ZELLE_SND_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;

  console.log(`Simulating Zelle send: $${data.amount} from ${data.fromAccount} to ${data.recipientName} (${data.recipientIdentifier}) Transaction ID: ${transactionId}`);
  return { success: true, message: `Zelle® payment of $${data.amount.toFixed(2)} to ${data.recipientName} initiated. Transaction ID: ${transactionId}` };
}

const zelleRequestSchemaServer = z.object({
  recipientIdentifier: z.string(),
  recipientName: z.string(),
  amount: z.number(),
  memo: z.string().optional(),
});
type ZelleRequestFormValuesServer = z.infer<typeof zelleRequestSchemaServer>;

export async function handleZelleRequestMoney(data: ZelleRequestFormValuesServer): Promise<ActionResult> {
  console.log("Server Action: handleZelleRequestMoney called with data:", data);
  await new Promise(resolve => setTimeout(resolve, 1500));

  if (data.amount > 2000) { // Example limit
    return { success: false, error: "Zelle® request limit is $2000 per transaction." };
  }
  // In a real app:
  // 1. Interact with Zelle SDK/API to initiate request.
  // 2. Record request in database.
  // 3. Send notifications.
  const requestId = `ZELLE_REQ_${Date.now()}_${Math.random().toString(36).substring(2, 10)}`;

  console.log(`Simulating Zelle request: $${data.amount} from ${data.recipientName} (${data.recipientIdentifier}). Request ID: ${requestId}`);
  return { success: true, message: `Zelle® request for $${data.amount.toFixed(2)} from ${data.recipientName} sent. Request ID: ${requestId}` };
}
